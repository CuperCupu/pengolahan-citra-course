<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="description" content="Image processing">
    <meta name="keywords" content="Image Processing, Equalization, Contrast Stretching, Histogram Specification">
    <meta name="author" content="Suhendi">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Processor</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.2/Chart.bundle.min.js"></script>
    <script src="exif.js"></script>
    <link rel="icon" href="/icon.png" type="image/png"/>
    <link rel="shortcut icon" href="/icon.png" type="image/png"/>
<style>
/* @media screen and (min-width: 600px) and (orientation:portrait) {
     
    :root {
        font-size: 32px;
    }

} */
.btn {
    white-space:normal !important;
    word-wrap: break-word;
}
.image-box {
    margin: 1rem;
    box-shadow: 0 3px 10px 0 #00000022;
    background-color: rgba(225, 225, 225, 1);
}
</style>
</head>
<body onload="init();">
    <video width=640 height=480 id="video" style="display: none;" controls autoplay></video>
    <div class="container">
        <div class="row d-flex justify-content-center mb-2 mt-2">
            <h1>Image Processor</h1>
        </div>
        <div class="row d-flex ml-1 mr-1">
            <div class="col-12">
                <div class="col-lg-6 col-md-8 col-12 mx-auto">
                    <div id="snapshot" class="row d-flex mt-1">
                        <button class="col btn btn-dark" id="webcam_start" onclick="startWebcam(); $('#webcam_start').addClass('d-none');">Start Webcam</button> 
                        <div id="webcam_control" class="col d-none" style="padding: 0;">
                            <button class="col btn btn-dark mr-1 mt-1" id="webcam_snapshot" onclick="snapshot();">Take Snapshot</button> 
                            <button class="col btn btn-dark mr-1 mt-1" id="webcam_stop" onclick="stopWebcam(); $('#webcam_start').removeClass('d-none'); $('#webcam_control').addClass('d-none');">Stop Webcam</button> 
                        </div>
                    </div>
                    <div class="row d-flex mt-1">
                        <input id="image_file_input" oninput="load_image_file(this.files[0]);" type="file" accept="image/*" capture="camera" style="display: none;">
                        <input class="col btn btn-dark" type="button" onclick="$('#image_file_input').click();" value="Take Picture">
                    </div>
                    <div id="controls" class="row d-none">
                    
                    </div>
                </div>
            </div>
            <div class="col-12">
                <div class="row d-flex justify-content-center align-items-center">
                    <div class="col-lg-6 col-md-8 col-12 d-flex justify-content-center align-items-center">
                        <canvas class="image-box" id="image_canvas" width="480" height="360" style="max-width: 100%; height: auto;"></canvas>
                    </div>
                    <div class="col-lg-6 col-md-8 col-12 d-flex justify-content-center align-items-center">
                        <canvas class="image-box" id="image_canvas_result" width="480" height="360" style="max-width: 100%; height: auto;"></canvas>
                    </div>
                    <!-- <div class="col-lg-6 col-md-8 col-12 d-flex justify-content-center align-items-center">
                        <canvas class="image-box" id="image_canvas_2" width="480" height="360" style="max-width: 100%; height: auto;"></canvas>
                    </div> -->
                </div>
            </div>
            <div class="col-12">
                <div class="row d-flex justify-content-center align-items-center">
                    <div class="btn-dark col-lg-5 col-md-7 col-12 d-flex px-1 py-2" style="min-height: 2rem; border-radius: 0.25rem;">
                        <span class="mx-2">Result: </span>
                        <span id="result"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
<script>
    navigator.getUserMedia = ( navigator.getUserMedia ||
                             navigator.webkitGetUserMedia ||
                             navigator.mozGetUserMedia ||
                             navigator.msGetUserMedia);

    var video;
    var webcamStream;
    var image, image_after, imageProcess;
    var counts;
    Math.clamp=function(a,b,c){return Math.max(b,Math.min(c,a));}

    function startWebcam() {
        if (navigator.getUserMedia) {
           navigator.getUserMedia (
                // constraints
                {
                    video: {width: {exact: 640}, height: {exact: 480}},
                    audio: false
                },

                // successCallback
                function(localMediaStream) {
                    video = document.querySelector('video');
                    video.srcObject = localMediaStream;
                    webcamStream = localMediaStream;
                    $("#webcam_control").removeClass("d-none");
                },

                // errorCallback
                function(err) {
                    console.log("The following error occured: " + err);
                    if (err instanceof DOMException) {
                        alert("Webcam permission denied.");
                        $("#snapshot").removeClass("d-flex");
                        $("#snapshot").addClass("d-none");
                    }
                }
           );
        } else {
            console.log("getUserMedia not supported");
            $("#snapshot").removeClass("d-flex");
            $("#snapshot").addClass("d-none");
        }
    }

    function stopWebcam() {
        if (webcamStream) {
            webcamStream.getTracks().forEach(function (track) { track.stop(); });
        }
    }
    //---------------------
    // TAKE A SNAPSHOT CODE
    //---------------------
    var canvas, ctx, canvas2, ctx2, reference_freq;
    var custom_spec_enabled = true;

    function init() {
        // Get the canvas and obtain a context for
        // drawing in it
        canvas = document.getElementById("image_canvas");
        canvas2 = document.getElementById("image_canvas_result");
        ctx = canvas.getContext('2d');
        ctx2 = canvas2.getContext('2d');
        if ((location.protocol !== "https:") && (location.hostname != "localhost")) {
            $("#snapshot").removeClass("d-flex");
            $("#snapshot").addClass("d-none");
        }

    }

    function snapshot() {
        if (video) {
            var width = video.width;
            var height = video.height;
            var orientation = screen.msOrientation || (screen.orientation || screen.mozOrientation || {}).type;
            if ((orientation === "landscape-primary") ||(orientation === "landscape-secondary")) {
            } else if ((orientation === "portrait-primary") || (orientation === "portrait-secondary") ){
                width = video.height;
                height = video.width;
            }
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(video, 0, 0);
            main();            
            $("#controls").removeClass("d-none");
        }
    }

    function load_image_file(img_url) {
        try {
            var img = new Image();
            var reader = new FileReader();
            img.setAttribute('crossOrigin', 'anonymous');

            img.onload = function () {
                var rotation = 0;
                var orientation = 0;
                EXIF.getData(this, function() {
                    orientation = EXIF.getTag(this, "Orientation");
                    if ((orientation == 1) || (orientation == 2)) {
                        rotation = 0;
                    } else if ((orientation == 3) || (orientation == 4)) {
                        rotation = 180;
                    } else if ((orientation == 5) || (orientation == 6)) {
                        rotation = -90;
                    } else if ((orientation == 7) || (orientation == 8)) {
                        rotation = 90;
                    }
                });
                var width = 0;
                var height = 0;
                if ((rotation == 0) || (rotation == 180) || (rotation == -180)) {
                    canvas.height = canvas.width * (img.height / img.width);
                    width = canvas.height;
                    height = canvas.width;
                    canvas2.height = canvas.height;
                } else {
                    canvas.height = canvas.width * (img.width / img.height);
                    width = canvas.width;
                    height = canvas.height;
                    canvas2.height = canvas.height;
                }
                rotation = rotation / 180 * Math.PI;
                ctx.save();
                ctx.translate(canvas.width/2, canvas.height/2);
                ctx.rotate(-rotation);
                ctx.drawImage(this, -height/2, -width/2, height, width);
                ctx.restore();
                main();
                $("#controls").removeClass("d-none");
            };

            reader.onload = function(event) {
                the_url = event.target.result
                img.src = the_url;
            }
            reader.readAsDataURL(img_url);
        } catch(err) {
            if (err.name == "TypeError") {

            } else {
                alert("loading: " + err);
            }
        }
    }

    var preset = {}

    function detectOnce(image) {
        var boundary = findBoundary(image);
        if (boundary != null) {
            var matches = matchAll(boundary.code, 0.15);
            if (matches.length > 0) {
                var min = matches[0];
                for (var i = 1; i < matches.length; i++) {
                    if (min.error > matches[i].error) {
                        min = matches[i];
                    }
                }
                return  {
                    "name": min.name,
                    "matches": matches,
                    "boundary": boundary
                };
            }
            return  {
                "name": null,
                "matches": matches,
                "boundary": boundary
            };
    }
        return null;
    }

    function detectAll(image) {
        var string = "";
        var results = [];
        var result = detectOnce(image);
        while (result != null) {
            results.push(result)
            fill(image, result.boundary, new Color(0, 0, 0, 255));
            result = detectOnce(image);
        }
        results.sort(function (a, b) {
            if (a.boundary.start.x < b.boundary.start.x) {
                return -1;
            } else if (a.boundary.start.x > b.boundary.start.x) {
                return 1;
            } else {
                if (a.boundary.start.y < b.boundary.start.y) {
                    return -1;
                } else if (a.boundary.start.y > b.boundary.start.y) {
                    return 1;
                } else {
                    return 0;
                }
            }
        });
        for (var k in results) {
            if (results[k].name != null) {
                string += results[k].name;
            }
        }
        return string;
    }

    function main() {
        image = ctx.getImageData(0, 0, canvas.width, canvas.height);
        imageProcess = preprocessImage(image);
        ctx.mozImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;
        ctx.imageSmoothingEnabled = false;
        ctx.putImageData(image, 0, 0);
        
        image_after = skeletonizeImage(imageProcess);
        ctx2.putImageData(image_after, 0, 0);
        var result = detectAll(image);
        if (result) {
            $("#result").text(result);
        } else {
            $("#result").text("No match");
        }
    }

    function loadPreset() {
        $.ajax("preset.json", {
            dataType: "json",
            success: function(response) {
                for (var i in response) {
                    preset[i] = new ChainCode(response[i]);
                }
            }
        });
    }

    function preprocessImage(img) {
        try {
            var newimg = ctx.createImageData(img.width, img.height);
            for (var i = 0; i < img.data.length; i += 4) {
                let grey = (img.data[i] + img.data[i + 1] + img.data[i + 2]) / 3;
                if (grey > 127) {
                    grey = 255;
                } else {
                    grey = 0;
                }
                newimg.data[i] = grey;
                newimg.data[i + 1] = grey;
                newimg.data[i + 2] = grey;
                newimg.data[i + 3] = 255;
            }
            return newimg;
        } catch(err) {
            alert("preprocess: " + err.message);
        }
    }

    var getImgPixelAt = function(img, x, y) {
        let offset = (x + y * img.width)  * 4;
        if ((offset < 0) || (offset > img.data.length)) {
            return null;
        }
        return new Color(img.data[offset], img.data[offset + 1], img.data[offset + 2], img.data[offset + 3]);
    }

    var setImgPixelAt = function(img, x, y, color) {
        let offset = (x + y * img.width)  * 4;
        if ((offset < 0) || (offset > img.data.length)) {
            return false;
        }
        img.data[offset] = color.r;
        img.data[offset + 1] = color.g;
        img.data[offset + 2] = color.b;
        img.data[offset + 3] = color.a;
        return true;
    }

    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }

    class Color {
        constructor(r, g, b, a=255) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }

        getBrightness() {
            return (this.r + this.g + this.b) / 3;
        }
    }

    class ChainCode {
        constructor(code = "") {
            this.code = code;
            this.length = code.length;
        }

        addCode(code) {
            this.code += code;
            this.length++;
        }

        toString() {
            return this.code;
        }

        getAt(x) {
            var index = Math.round(x * this.length);
            if (index === this.length) {
                index--;
            }
            return this.code[index];
        }

        match(other) {
            var min, max = null;
            if (this.length > other.length) {
                max = this;
                min = other;
            } else {
                max = other;
                min = this;
            }
            // Compare higher to lower.
            var length1 = max.length;
            var error1 = 0;
            for (var i = 0; i < length1; i++) {
                // error += max.code[i] !== min.getAt(i / length) ? 1 : 0;
                var diff = getDirDiff(max.code[i], min.getAt(i / length1));
                // console.log(max.code[i], min.getAt(i / length), diff);
                error1 += diff <= 1 ? 0 : 1;
                // error1 += diff;
            }
            // Compare lower to higher.
            var length2 = min.length;
            var error2 = 0;
            for (var i = 0; i < length2; i++) {
                // error += max.code[i] !== min.getAt(i / length) ? 1 : 0;
                var diff = getDirDiff(min.code[i], max.getAt(i / length2));
                // console.log(max.code[i], min.getAt(i / length), diff);
                error2 += diff <= 1 ? 0 : 1;
                // error2 += diff;
            }
            error1 = error1 / length1;
            error2 = error2 / length2;
            return (error1 + error2) / 2;
        }
    }

    var findNonEmpty = function(img) {
        let x = 0;
        let y = 0;
        let found = false;
        while ((!found) && ((x < img.width) && (y < img.height))) {
            found = getImgPixelAt(img, x, y).r > 0;
            if (!found) {
                x += 1;
                if (x >= img.width) {
                    x = 0;
                    y += 1;
                }
            }
        }
        if (found) {
            return {
                x: x,
                y: y
            }
        }
        return null;
    }

    var getOffset = function(dir) {
        if (dir == 0) {
            return new Point(0, 0);
        } else if (dir == 1) { // Right
            return new Point(1, 0);
        } else if (dir == 2) { // Up-Right
            return new Point(1, -1);
        } else if (dir == 3) { // Up
            return new Point(0, -1);
        } else if (dir == 4) { // Up-Left
            return new Point(-1, -1);
        } else if (dir == 5) { // Left
            return new Point(-1, 0);
        } else if (dir == 6) { // Down-Left
            return new Point(-1, 1);
        } else if (dir == 7) { // Down
            return new Point(0, 1);
        } else if (dir == 8) { // Down-Right
            return new Point(1, 1);
        }
        return null;
    }

    var getSide = function(dir) {
        var off = getOffset(dir);
        return new Point(-off.y, off.x);
    }

    var offsetDir = function(dir, off) {
        dir += off;
        if (dir > 8) {
            dir = 1;
        } else if (dir < 1) {
            dir = 8;
        }
        return dir;
    }

    var getDirDiff = function(dir1, dir2) {
        return Math.min(Math.abs(dir1 - dir2), 8 - Math.abs(dir1 - dir2));
    }

    var nextDir = function(dir) {
        return offsetDir(dir, 1);
    }

    var prevDir = function(dir) {
        return offsetDir(dir, -1);
    }

    function findBoundary(img) {
        try {
            var result = new ChainCode();
            var x, y, sx, sy = 0;
            var dir = 1;
            var pos = findNonEmpty(img);
            if (pos != null) {
                sx = x = pos.x;
                sy = y = pos.y;
                var iter = 0;
                var max_iter = img.data.length / 4;
                var trace = []
                var opaque = false;
                do {
                    opaque = false;
                    var it = 0;
                    dir = offsetDir(dir, 2);
                    while ((!opaque) && (it < 8)) {
                        var off = getOffset(dir);
                        var color = getImgPixelAt(img, x + off.x, y + off.y);
                        opaque = color == null ? false: color.r > 0;
                        if (!opaque) {
                            it++;
                            dir = prevDir(dir);
                        } else {
                            result.addCode(dir);
                            trace.push(new Point(x, y));
                            x += off.x;
                            y += off.y;
                        }
                    }
                    iter++;
                } while (((x != sx) || (y != sy)) && (opaque) && (iter < max_iter));
                for (var i = 0; i < trace.length; i++) {
                    setImgPixelAt(img, trace[i].x, trace[i].y, new Color(255, 0, 0, 255));
                }
                setImgPixelAt(img, sx, sy, new Color(0, 255, 0, 255));
                ctx.mozImageSmoothingEnabled = false;
                ctx.webkitImageSmoothingEnabled = false;
                ctx.msImageSmoothingEnabled = false;
                ctx.imageSmoothingEnabled = false;
                return {
                    "start": new Point(sx, sy),
                    "code": result,
                    "trace": trace
                };
            }
            return null;
        } catch(err) {
            alert("boundary: " + err);
        }
    }

    var fill = function(img, boundary, color) {
        // Determine fill region.
        var min = new Point(img.width - 1, img.height - 1);
        var max = new Point(0, 0);
        for (var i = 0; i < boundary.trace.length; i++) {
            if (boundary.trace[i].x > max.x) {
                max.x = boundary.trace[i].x;
            }
            if (boundary.trace[i].x < min.x) {
                min.x = boundary.trace[i].x;
            }
            if (boundary.trace[i].y > max.y) {
                max.y = boundary.trace[i].y;
            }
            if (boundary.trace[i].y < min.y) {
                min.y = boundary.trace[i].y;
            }
        }
        // Boundary map.
        var width = (max.x - min.x) + 1;
        var height = (max.y - min.y) + 1;
        var boundary_map = new Array(width * height);
        // Fill with false value.
        for (var i = 0; i < boundary_map.length; i++) {
            boundary_map[i] = false;
        }
        for (var i = 0; i < boundary.trace.length; i++) {
            boundary_map[(boundary.trace[i].x - min.x) + ((boundary.trace[i].y - min.y) * width)] = true;
        }
        var boundaryAt = function(tx, ty) {
            return boundary_map[tx + (ty * width)];
        }
        // Start filling.
        // Flood fill.
        var x = boundary.start.x - min.x + 1;
        var y = boundary.start.y - min.y + 1;
        var next = []
        var indexOf = function(x, y) {
            var found = false;
            var i = 0;
            while ((!found) && (i < next.length)) {
                found = ((x === next[i].x) && (y === next[i].y));
                if (!found) {
                    i++;
                }
            }
            if (found) {
                return i;
            }
            return -1;
        }
        var iter = 0;

        var startFill = function(x, y) {
            next.push(new Point(x, y));
            while (next.length > 0) {
                var curr = next.pop();
                x = curr.x;
                y = curr.y;
                if (!boundaryAt(x, y)) {
                    boundary_map[x + (y * width)] = true;
                    setImgPixelAt(img, x + min.x, y + min.y, color);
                    iter++;
                    if (!boundaryAt(x + 1, y)) {
                        if (indexOf(x + 1, y) === -1) {
                            next.push(new Point(x + 1, y));
                        }
                    }
                    if (!boundaryAt(x, y + 1)) {
                        if (indexOf(x, y + 1) === -1) {
                            next.push(new Point(x, y + 1));
                        }
                    }
                    if (!boundaryAt(x - 1, y)) {
                        if (indexOf(x - 1, y) === -1) {
                            next.push(new Point(x - 1, y));
                        }
                    }
                    if (!boundaryAt(x, y - 1)) {
                        if (indexOf(x, y - 1) === -1) {
                            next.push(new Point(x, y - 1));
                        }
                    }
                }
            }
        }
        
        startFill(x, y);
        for (var i = 0; i < boundary.trace.length; i++) {
            setImgPixelAt(img, boundary.trace[i].x, boundary.trace[i].y, color);
        }
        return img;
    }

    var matchAll = function(code, maxerror=-1) {
        /* return all name of preset that matches the code with maximum number of error <= maxerror.
         use maxerror === -1 to return all.
         return:
         [
             {
                 "name": ...,
                 "error": ...
             }
         ]
         */
        var result = []
        for (var name in preset) {
            var error = code.match(preset[name]);
            if ((maxerror === -1) || (error < maxerror)) {
                result.push({
                    "name": name,
                    "error": error
                });
            }
        }
        return result;
    }

    // Eight-directional neighbours
    var neighbours =  [[0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1]];

    // Neighbours Group from Zhang-Suen Rules
    var neighboursGroup = [[[0, 2, 4], [2, 4, 6]], [[0, 2, 6], [0, 4, 6]]];
    var toBlack = new Array();
    function skeletonizeImage(img) {
        var firstStep = false;
        var hasChanged;
        do {    // repeatly checking for reomving side to get the skeleton
            hasChanged = false;
            firstStep = !firstStep;
            for (var i = 0; i < img.data.length; i += 4) {
                if (img.data[i] != 255)
                    continue;
                var num = nNeighbours(img, i);
                if (num < 2 || num > 6)
                    continue;
                if (nTransition(img, i) != 1)
                    continue;
                if (!atLeastOneBlack(img, i, firstStep ?0 :1))
                    continue;
                toBlack.push(i);
                hasChanged = true;
            }
            for (var i = 0; i < toBlack.length; i++){
                img.data[toBlack[i]] = 0;
                img.data[toBlack[i] + 1] = 0;
                img.data[toBlack[i] + 2] = 0;
            }
            toBlack = new Array();
            
        } while((firstStep || hasChanged));

        return img;
    }

    function nNeighbours(img, idx) {
        /*
        Find white surroundings on the all eight-directions
        */
        var count = 0;
        var temp;
        
        var tempRow = Math.floor(idx / img.width / 4);
        var tempCol = Math.floor((idx % (img.width * 4) / 4));
        for (var i = 0; i < neighbours.length - 1; i++) {
            temp = ((tempRow + neighbours[i][1]) * img.width * 4)+ ((tempCol + neighbours[i][0]) * 4);
            if (img.data[temp] == 255){
                count++;
            }
        }
        return count;
    }

    function nTransition(img, idx) {
        /*
        Find total transition from 0 (black) to 255 (white) from the surroundings
        */
        var count = 0;
        var temp1, temp2;
        
        var tempRow = Math.floor(idx / img.width / 4);
        var tempCol = Math.floor((idx % (img.width * 4) / 4));
        for (var i = 0; i < neighbours.length - 1; i++) {
            temp1 = ((tempRow + neighbours[i][1]) * img.width * 4) + ((tempCol + neighbours[i][0]) * 4);
            temp2 = ((tempRow + neighbours[i + 1][1]) * img.width * 4) + ((tempCol + neighbours[i + 1][0]) * 4);
            if (img.data[temp1] === 0)
                if (img.data[temp2] === 255)
                    count++;
        }
        temp1 = ((tempRow + neighbours[neighbours.length - 1][1]) * img.width * 4) + ((tempCol + neighbours[neighbours.length - 1][0]) * 4);
        temp2 = ((tempRow + neighbours[0][1]) * img.width * 4) + ((tempCol + neighbours[0][0]) * 4);
        if (img.data[temp1] === 0)
            if (img.data[temp2] === 255)
                count++;
        return count;
    }

    function atLeastOneBlack(img, idx, step) {
        /*
        Find at least one black from the surrounding according to the neighbours groups
        */
        var count = 0;
        var temp;
        var group = neighboursGroup[step];
        var tempRow = Math.floor(idx / img.width / 4);
        var tempCol = Math.floor((idx % (img.width * 4) / 4));

        for (var i = 0; i < 2; i++) {
            for (var j = 0; j < group[i].length; j++) {
                var surround = neighbours[group[i][j]];
                temp = ((tempRow + surround[1]) * img.width * 4) + ((tempCol + surround[0]) * 4);
                if (img.data[temp] === 0) {
                    count++;
                    break;
                }
            }
        }
        return count > 1;
    }

    $(document).ready(function() {
        loadPreset();
    });

</script>