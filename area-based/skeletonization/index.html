<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="description" content="Image processing">
    <meta name="keywords" content="Image Processing, Equalization, Contrast Stretching, Histogram Specification">
    <meta name="author" content="Suhendi">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Processor</title>
    <link rel="stylesheet" href="../../bootstrap.min.css">
    <script src="../../jquery-3.3.1.min.js"></script>
    <script src="../../popper.min.js"></script>
    <script src="../../bootstrap.min.js"></script>
    <script src="../../exif.js"></script>
    <link rel="icon" href="/icon.png" type="image/png"/>
    <link rel="shortcut icon" href="/icon.png" type="image/png"/>
<style>
/* @media screen and (min-width: 600px) and (orientation:portrait) {
     
    :root {
        font-size: 32px;
    }

} */
.btn {
    white-space:normal !important;
    word-wrap: break-word;
}
.image-box {
    margin: 1rem;
    box-shadow: 0 3px 10px 0 #00000022;
    background-color: rgba(225, 225, 225, 1);
}
</style>
</head>
<body onload="init();">
    <video width=640 height=480 id="video" style="display: none;" controls autoplay></video>
    <div class="container">
        <div class="row d-flex justify-content-center mb-2 mt-2">
            <h1>Image Processor</h1>
        </div>
        <div class="row d-flex ml-1 mr-1">
            <div class="col-12">
                <div class="col-lg-6 col-md-8 col-12 mx-auto">
                    <div id="snapshot" class="row d-none mt-1">
                        <button class="col btn btn-dark" id="webcam_start" onclick="startWebcam(); $('#webcam_start').addClass('d-none');">Start Webcam</button> 
                        <div id="webcam_control" class="col d-none" style="padding: 0;">
                            <button class="col btn btn-dark mr-1 mt-1" id="webcam_snapshot" onclick="snapshot();">Take Snapshot</button> 
                            <button class="col btn btn-dark mr-1 mt-1" id="webcam_stop" onclick="stopWebcam(); $('#webcam_start').removeClass('d-none'); $('#webcam_control').addClass('d-none');">Stop Webcam</button> 
                        </div>
                    </div>
                    <div class="row d-flex mt-1">
                        <input id="image_file_input" oninput="load_image_file(this.files[0]);" type="file" accept="image/*" capture="camera" style="display: none;">
                        <input class="col btn btn-dark" type="button" onclick="$('#image_file_input').click();" value="Take Picture">
                    </div>
                    <div id="controls" class="row d-none">
                    
                    </div>
                </div>
            </div>
            <div class="col-12">
                <div class="row d-flex justify-content-center align-items-center">
                    <div class="col-lg-6 col-md-8 col-12 d-flex justify-content-center align-items-center">
                        <canvas class="image-box" id="image_canvas" width="480" height="360" style="max-width: 100%; height: auto;"></canvas>
                    </div>
                    <div class="col-lg-6 col-md-8 col-12 d-flex justify-content-center align-items-center">
                        <canvas class="image-box" id="image_canvas_result" width="480" height="360" style="max-width: 100%; height: auto;"></canvas>
                    </div>
                    <!-- <div class="col-lg-6 col-md-8 col-12 d-flex justify-content-center align-items-center">
                        <canvas class="image-box" id="image_canvas_2" width="480" height="360" style="max-width: 100%; height: auto;"></canvas>
                    </div> -->
                </div>
            </div>
            <div class="col-12">
                <div class="row d-flex justify-content-center align-items-center">
                    <div class="btn-dark col-lg-5 col-md-7 col-12 d-flex px-1 py-2" style="min-height: 2rem; border-radius: 0.25rem;">
                        <span class="mx-2">Result: </span>
                        <span id="result"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
<script>
    navigator.getUserMedia = ( navigator.getUserMedia ||
                             navigator.webkitGetUserMedia ||
                             navigator.mozGetUserMedia ||
                             navigator.msGetUserMedia);

    var video;
    var webcamStream;
    var image, image_after, imageProcess;
    var counts;
    Math.clamp=function(a,b,c){return Math.max(b,Math.min(c,a));}

    function startWebcam() {
        if (navigator.getUserMedia) {
           navigator.getUserMedia (
                // constraints
                {
                    video: {width: {exact: 640}, height: {exact: 480}},
                    audio: false
                },

                // successCallback
                function(localMediaStream) {
                    video = document.querySelector('video');
                    video.srcObject = localMediaStream;
                    webcamStream = localMediaStream;
                    $("#webcam_control").removeClass("d-none");
                },

                // errorCallback
                function(err) {
                    console.log("The following error occured: " + err);
                    if (err instanceof DOMException) {
                        alert("Webcam permission denied.");
                        $("#snapshot").removeClass("d-flex");
                        $("#snapshot").addClass("d-none");
                    }
                }
           );
        } else {
            console.log("getUserMedia not supported");
            $("#snapshot").removeClass("d-flex");
            $("#snapshot").addClass("d-none");
        }
    }

    function stopWebcam() {
        if (webcamStream) {
            webcamStream.getTracks().forEach(function (track) { track.stop(); });
        }
    }
    //---------------------
    // TAKE A SNAPSHOT CODE
    //---------------------
    var canvas, ctx, canvas2, ctx2, reference_freq;
    var custom_spec_enabled = true;

    function init() {
        // Get the canvas and obtain a context for
        // drawing in it
        canvas = document.getElementById("image_canvas");
        canvas2 = document.getElementById("image_canvas_result");
        ctx = canvas.getContext('2d');
        ctx2 = canvas2.getContext('2d');
        if ((location.protocol !== "https:") && (location.hostname != "localhost")) {
            $("#snapshot").removeClass("d-flex");
            $("#snapshot").addClass("d-none");
        }

    }

    function snapshot() {
        if (video) {
            var width = video.width;
            var height = video.height;
            var orientation = screen.msOrientation || (screen.orientation || screen.mozOrientation || {}).type;
            if ((orientation === "landscape-primary") ||(orientation === "landscape-secondary")) {
            } else if ((orientation === "portrait-primary") || (orientation === "portrait-secondary") ){
                width = video.height;
                height = video.width;
            }
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(video, 0, 0);
            main();            
            $("#controls").removeClass("d-none");
        }
    }

    function load_image_file(img_url) {
        try {
            var img = new Image();
            var reader = new FileReader();
            img.setAttribute('crossOrigin', 'anonymous');

            img.onload = function () {
                var rotation = 0;
                var orientation = 0;
                EXIF.getData(this, function() {
                    orientation = EXIF.getTag(this, "Orientation");
                    if ((orientation == 1) || (orientation == 2)) {
                        rotation = 0;
                    } else if ((orientation == 3) || (orientation == 4)) {
                        rotation = 180;
                    } else if ((orientation == 5) || (orientation == 6)) {
                        rotation = -90;
                    } else if ((orientation == 7) || (orientation == 8)) {
                        rotation = 90;
                    }
                });
                var width = 0;
                var height = 0;
                if ((rotation == 0) || (rotation == 180) || (rotation == -180)) {
                    canvas.height = canvas.width * (img.height / img.width);
                    width = canvas.height;
                    height = canvas.width;
                    canvas2.height = canvas.height;
                } else {
                    canvas.height = canvas.width * (img.width / img.height);
                    width = canvas.width;
                    height = canvas.height;
                    canvas2.height = canvas.height;
                }
                rotation = rotation / 180 * Math.PI;
                ctx.save();
                ctx.translate(canvas.width/2, canvas.height/2);
                ctx.rotate(-rotation);
                ctx.drawImage(this, -height/2, -width/2, height, width);
                ctx.restore();
                main();
                $("#controls").removeClass("d-none");
            };

            reader.onload = function(event) {
                the_url = event.target.result
                img.src = the_url;
            }
            reader.readAsDataURL(img_url);
        } catch(err) {
            if (err.name == "TypeError") {

            } else {
                alert("loading: " + err);
            }
        }
    }

    var preset = {}

    function detectOnce(image) {
        var boundary = findBoundary(image);
        if (boundary != null) {
            var matches = matchAll(boundary.code, 0.15);
            if (matches.length > 0) {
                var min = matches[0];
                for (var i = 1; i < matches.length; i++) {
                    if (min.error > matches[i].error) {
                        min = matches[i];
                    }
                }
                return  {
                    "name": min.name,
                    "matches": matches,
                    "boundary": boundary
                };
            }
            return  {
                "name": null,
                "matches": matches,
                "boundary": boundary
            };
    }
        return null;
    }

    function detectAll(image) {
        var string = "";
        var results = [];
        var result = detectOnce(image);
        while (result != null) {
            results.push(result)
            fill(image, result.boundary, new Color(0, 0, 0, 255));
            result = detectOnce(image);
        }
        results.sort(function (a, b) {
            if (a.boundary.start.x < b.boundary.start.x) {
                return -1;
            } else if (a.boundary.start.x > b.boundary.start.x) {
                return 1;
            } else {
                if (a.boundary.start.y < b.boundary.start.y) {
                    return -1;
                } else if (a.boundary.start.y > b.boundary.start.y) {
                    return 1;
                } else {
                    return 0;
                }
            }
        });
        for (var k in results) {
            if (results[k].name != null) {
                string += results[k].name;
            }
        }
        return string;
    }

    function main() {
        image = ctx.getImageData(0, 0, canvas.width, canvas.height);
        imageProcess = preprocessImage(image);
        ctx.mozImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;
        ctx.imageSmoothingEnabled = false;
        ctx.putImageData(image, 0, 0);
        
        image_after = postprocessImage(skeletonizeImage(imageProcess));
        img_info = {
            image: image_after,
            ends: [],
            cross: []
        }
        var endPoints = findEndPoints(image_after);
        for (var i in endPoints) {
            var p = endPoints[i];
            x = Math.floor((p % (image_after.width * 4) / 4));
            y = Math.floor(p / image_after.width / 4);
            img_info.ends.push({x: x, y: y})
        }
        var crucialPoints = findCrucialPoints(image_after);
        for (var i in crucialPoints) {
            var p = crucialPoints[i];
            x = Math.floor((p % (image_after.width * 4) / 4));
            y = Math.floor(p / image_after.width / 4);
            img_info.cross.push({x: x, y: y})
        }
        var result = predictFromInfo(img_info);
        $("#result").text(result);
        ctx2.putImageData(image_after, 0, 0);
        // var result = detectOnce(image_after);
        // if (result.name) {
        //     $("#result").text(result.name);
        // } else {
        //     $("#result").text("No match");
        // }
    }

    function findBound(img) {
        var min = {
            x: img.width,
            y: img.height,
        }
        var max = {
            x: 0,
            y: 0,
        }
        for (var y = 0; y < img.height; y++) {
            for (var x = 0; x < img.width; x++) {
                var p = getImgPixelAt(img, x, y);
                if (p.r > 0) {
                    if (x < min.x) {
                        min.x = x;
                    }
                    if (x > max.x) {
                        max.x = x;
                    }
                    if (y < min.y) {
                        min.y = y;
                    }
                    if (y > max.y) {
                        max.y = y;
                    }
                }
            }
        }
        return {
            min: min,
            max: max,
        }
    }

    function getOffsetFromCenter(x, y, center) {
        off = {
            x: 0,
            y: 0,
        }
        if (x < center.x) {
            off.x = -1;
        } else if (x > center.x) {
            off.x = 1;
        }
        if (y < center.y) {
            off.y = -1;
        } else if (y > center.y) {
            off.y = 1;
        }
        return off;
    }

    function categorizeQuadrant(off) {
        if ((off.x == 0) && (off.y == 0)) {
            return 0;
        } else if ((off.x == 1) && (off.y == 0)) {
            return 1;
        } else if ((off.x == 1) && (off.y == -1)) {
            return 2;
        } else if ((off.x == 0) && (off.y == -1)) {
            return 3;
        } else if ((off.x == -1) && (off.y == -1)) {
            return 4;
        } else if ((off.x == -1) && (off.y == 0)) {
            return 5;
        } else if ((off.x == -1) && (off.y == 1)) {
            return 6;
        } else if ((off.x == 0) && (off.y == 1)) {
            return 7;
        } else if ((off.x == 1) && (off.y == 1)) {
            return 8;
        }
        return null;
    }

    function endPointDirection(x, y, image) {
        var dir = 0;
        var i = 1;
        while (i < 9) {
            var off = getOffset(i);
            var c = getImgPixelAt(image, x + off.x, y + off.y);
            if (c.r > 0) {
                dir = i;
                i = 9;
            }
            i++;
        }
        return offsetDir(dir, 4);
    }

    function predictFromInfo(info) {
        // Prediction for 8, 0, 4 are easily determined.
        if ((info.cross.length == 2) && (info.ends.length == 0)) {
            return "8";
        } else if ((info.cross.length == 0) && (info.ends.length == 0)) {
            return "0";
        } else if ((info.cross.length == 1) && (info.ends.length == 2)) {
            return "4";
        }
        // Get the number of end point in specific quadrants.
        var bound = findBound(info.image);
        var center = {
            x: (bound.max.x + bound.min.x) / 2,
            y: (bound.max.y + bound.min.y) / 2
        }
        var quadrants = {};
        for (var i = 0; i < 9; i++) {
            quadrants[i] = 0;
        }
        for (var i in info.ends) {
            let o = getOffsetFromCenter(info.ends[i].x, info.ends[i].y, center);
            let q = categorizeQuadrant(o);
            info.ends[i].offset = o;
            info.ends[i].quadrant = q;
            quadrants[q]++;
        }
        // Find the end points of the directions.
        var directions = {};
        for (var i = 0; i < 9; i++) {
            directions[i] = 0;
        }
        for (var i in info.ends) {
            let d = endPointDirection(info.ends[i].x, info.ends[i].y, info.image);
            info.ends[i].direction = d;
            directions[d]++;
        }
        // Match info with heuristic.
        if (info.cross.length == 1) {
            let top = quadrants[2] + quadrants[3] + quadrants[4];
            let bottom = quadrants[6] + quadrants[7] + quadrants[8];
            if ((top == 1) && (bottom == 0)) {
                return "6";
            } else if ((top == 0) && (bottom == 1)) {
                return "9";
            } 
        } else if (info.cross.length == 0) {
            if (info.ends.length == 2) {
                if ((quadrants[3] == 1) && (quadrants[7] == 1)) {
                    return "1";
                } else if ((quadrants[4] == 1) && (quadrants[8] == 1)) {
                    var left = directions[4] + directions[5] + directions[6] + directions[7];
                    if ((left == 1) && (directions[1] == 1)) {
                        return "2";
                    } else {
                        var upper_left = 0;
                        var lower_left = 0;
                        var lower_right = 0;
                        for (var i in info.ends) {
                            let d = info.ends[i].direction;
                            let o = info.ends[i].offset;
                            if ((d >= 4) && (d <= 6)) {
                                if (o.y < 0) {
                                    upper_left++;
                                } else if (o.y > 0) {
                                    lower_left++;
                                }
                            } else if (((d == 1) || (d == 7)) && (o.y > 0)) {
                                lower_right++;
                            }
                        }
                        if ((upper_left == 1) && (lower_right == 1)) {
                            return "1";
                        } else if ((upper_left == 1) && (lower_left == 1)) {
                            return "7";
                        }
                        return "1";
                    }
                } else if ((quadrants[4] == 1) && ((quadrants[6] == 1) || (quadrants[7] == 1))) {
                    var upper_left = 0;
                    var lower_left = 0;
                    var lower_straight_left = 0;
                    for (var i in info.ends) {
                        let d = info.ends[i].direction;
                        let o = info.ends[i].offset;
                        if ((d >= 4) && (d <= 6)) {
                            if (o.y < 0) {
                                upper_left++;
                            } else if (o.y > 0) {
                                if (d == 5) {
                                    lower_straight_left++;
                                }
                                lower_left++;
                            }
                        }
                    }
                    if ((upper_left == 1) && (lower_straight_left == 1)) {
                        return "1";
                    } else if ((upper_left == 1) && (lower_left == 1)) {
                        return "7";
                    }
                    return "3";
                    // var diagonal_left = directions[6] + directions[7] + directions[5];
                    // var left = directions[4] + directions[5] + directions[6];
                    // if ((diagonal_left > 0) && (directions[5] > 0)) {
                    //     return "1";
                    // } else if (((left == 1) && (directions[7] == 1)) || ((left == 2) && (directions[6] == 1))) {
                    //     return "7"
                    // }
                    // return "3";
                } else if ((quadrants[2] == 1) && (quadrants[6] == 1)) {
                    return "5";
                }
            }
        }
        return "No Match";
    }

    function loadPreset() {
        chaincodes = {
            "0": "1111111111111181111181118181818818888878887878778877877878777787877777877778777777877777777787777777777778777777777777777777777776777777777777767777777767777767777767777767677777667767767676776667666666665656556565555655555565555545555554555545545545454444444434434433434343343343343333433333433343333333433333333333433333333333333334333333332333333333333333323333333333233333332333323333233332332333233232332322332232222222121212121112111112",
            "1": "777677776777767776777678777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777733333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333334565655655655655655655565565556556665666656566565665656566566767676767676766762323232323232323232121212212121212221221222221112111211211121121121121121211222333233323333233332333",
            "2": "8111111111811111181811811818181888888878878787787778777787777877777777776777776777767777677677667766767667667666666666666666666666666666666666566666666666666666666667666776777677677677767767776776777788881111111111111111111111111111111111111111111111111111111111111111111111111111111155555555555555555555555555555555555555555555555555555555555555555555555555555555444455656565655656565665656566565622121221212121212121212121121233323323332332333233233233323323222232222222222222222212222222222222122222222222222222223222232232232323223323323333233332333332333333333343333433334333433434434443444544544545545545455555545555555554",
            "3": "1111111111111811111181111811818181818888818788787877887778777877778777777767776777677677676767766767567567656666677676766778788878787811188181888188888788878787877877787778777877778777786777776777767777677767767677676676766666666665665665656565555655555565555555655554555555545555554555545454545454444543444434443443344333332223232223776666776667778787878788887888888188818818181811118111111811111118111121111111211111121112112122122122122222223223223232323233233323333233332333332433334333343334333433343343434434444345444454544545543434344434465555555555555566566665666666656766623222222222212222121211111111111111222323232323212222222232232323232332332333233323333333433334333433434334344344444444545454554545555455555545555555555555",
            "4": "7776777677767776777678887777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777781111111111111111111111111115555555555555555555555555556777777777777777777777777777777777777777333333333333333333333333333333333333333455555555555555555555555555555555555555555555555555555555555555555555555555555555555554333233323332333233323332332333232232232232232232232232223232232223223223222322323223222322322322322321211212121121211212121121212223332333233323332333",
            "5": "1111111111111111111111111111111111111111111111111111111111111111111155555555555555555555555555555555555555555555555555555555555555555555",
            "6": "11111111111111181111181811181818881888788878778876666623222244334434444444454455455454555554555555555555555",
            "7": "65565565565567776776777677767776776777677776766676766767667666767667766767676767676767667676776767677677677676767767677677677767767767767767776777767777677677776777777767776777777777767776566656222212233233333333332333233333332333323323333233332333233233233233233323323323233232332323323323323232323223323232232323232323232232232322322232322322333323332332333233323332332333455555555555555555555555555555555555555555555555555555555555555555555555555555555555555555511111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111112112112112",
            "8": "11111111111118111111181181118181818818888887887878787778777877777876777767777677677767766776667666656666767676766688878788781818818888888878878787878777877778777787777877767777776777767777676776767667666766666566656565655655655555655555555654555555554555555455455454545454445444434434443343433434333343333433333333333323333233332333233322332232322223212212222232322322344434343434445444444334533433433343334333343333333333233332333233232232322221221221212111211121111112",
            "9": "111111111111118111118118118118818818888888887878788787787877787877777877777877777787777777787777777778777777777778877777777777677777777777767777777776777777767777677767776777667767767676776667667666666566656566555655655555655555565555555545555545555455454544544444434344334337787788788788818881881811811118111118111111112111111211111211211212122122222222223222323232323323322333323323332333323333333233333333323333333333332333333333334466656656656565655656556555655666565656556555655556555556555545555554545455454454444444434434343433434333344333334333334333333343233333332333332333332233332323323232322232222122122121212111121111112"
        }
        for (var i in chaincodes) {
            preset[i] = new ChainCode(chaincodes[i]);
        }
    }

    function preprocessImage(img) {
        try {
            var newimg = ctx.createImageData(img.width, img.height);
            for (var i = 0; i < img.data.length; i += 4) {
                let grey = (img.data[i] + img.data[i + 1] + img.data[i + 2]) / 3;
                if (grey > 127) {
                    grey = 255;
                } else {
                    grey = 0;
                }
                newimg.data[i] = grey;
                newimg.data[i + 1] = grey;
                newimg.data[i + 2] = grey;
                newimg.data[i + 3] = 255;
            }
            return newimg;
        } catch(err) {
            alert("preprocess: " + err.message);
        }
    }

    var getImgPixelAt = function(img, x, y) {
        let offset = (x + y * img.width)  * 4;
        if ((offset < 0) || (offset > img.data.length)) {
            return null;
        }
        return new Color(img.data[offset], img.data[offset + 1], img.data[offset + 2], img.data[offset + 3]);
    }

    var setImgPixelAt = function(img, x, y, color) {
        let offset = (x + y * img.width)  * 4;
        if ((offset < 0) || (offset > img.data.length)) {
            return false;
        }
        img.data[offset] = color.r;
        img.data[offset + 1] = color.g;
        img.data[offset + 2] = color.b;
        img.data[offset + 3] = color.a;
        return true;
    }

    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }

    class Color {
        constructor(r, g, b, a=255) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }

        getBrightness() {
            return (this.r + this.g + this.b) / 3;
        }
    }

    class ChainCode {
        constructor(code = "") {
            this.code = code;
            this.length = code.length;
        }

        addCode(code) {
            this.code += code;
            this.length++;
        }

        toString() {
            return this.code;
        }

        getAt(x) {
            var index = Math.round(x * this.length);
            if (index === this.length) {
                index--;
            }
            return this.code[index];
        }

        match(other) {
            var min, max = null;
            if (this.length > other.length) {
                max = this;
                min = other;
            } else {
                max = other;
                min = this;
            }
            // Compare higher to lower.
            var length1 = max.length;
            var error1 = 0;
            for (var i = 0; i < length1; i++) {
                // error += max.code[i] !== min.getAt(i / length) ? 1 : 0;
                var diff = getDirDiff(max.code[i], min.getAt(i / length1));
                // console.log(max.code[i], min.getAt(i / length), diff);
                error1 += diff <= 1 ? 0 : 1;
                // error1 += diff;
            }
            // Compare lower to higher.
            var length2 = min.length;
            var error2 = 0;
            for (var i = 0; i < length2; i++) {
                // error += max.code[i] !== min.getAt(i / length) ? 1 : 0;
                var diff = getDirDiff(min.code[i], max.getAt(i / length2));
                // console.log(max.code[i], min.getAt(i / length), diff);
                error2 += diff <= 1 ? 0 : 1;
                // error2 += diff;
            }
            error1 = error1 / length1;
            error2 = error2 / length2;
            return (error1 + error2) / 2;
        }
    }

    var findNonEmpty = function(img) {
        let x = 0;
        let y = 0;
        let found = false;
        while ((!found) && ((x < img.width) && (y < img.height))) {
            found = getImgPixelAt(img, x, y).r > 0;
            if (!found) {
                x += 1;
                if (x >= img.width) {
                    x = 0;
                    y += 1;
                }
            }
        }
        if (found) {
            return {
                x: x,
                y: y
            }
        }
        return null;
    }

    var getOffset = function(dir) {
        if (dir == 0) {
            return new Point(0, 0);
        } else if (dir == 1) { // Right
            return new Point(1, 0);
        } else if (dir == 2) { // Up-Right
            return new Point(1, -1);
        } else if (dir == 3) { // Up
            return new Point(0, -1);
        } else if (dir == 4) { // Up-Left
            return new Point(-1, -1);
        } else if (dir == 5) { // Left
            return new Point(-1, 0);
        } else if (dir == 6) { // Down-Left
            return new Point(-1, 1);
        } else if (dir == 7) { // Down
            return new Point(0, 1);
        } else if (dir == 8) { // Down-Right
            return new Point(1, 1);
        }
        return null;
    }

    var getSide = function(dir) {
        var off = getOffset(dir);
        return new Point(-off.y, off.x);
    }

    var offsetDir = function(dir, off) {
        dir += off;
        if (dir > 8) {
            dir = 1;
        } else if (dir < 1) {
            dir = 8;
        }
        return dir;
    }

    var getDirDiff = function(dir1, dir2) {
        return Math.min(Math.abs(dir1 - dir2), 8 - Math.abs(dir1 - dir2));
    }

    var nextDir = function(dir) {
        return offsetDir(dir, 1);
    }

    var prevDir = function(dir) {
        return offsetDir(dir, -1);
    }

    function findBoundary(img) {
        try {
            var result = new ChainCode();
            var x, y, sx, sy = 0;
            var dir = 1;
            var pos = findNonEmpty(img);
            if (pos != null) {
                sx = x = pos.x;
                sy = y = pos.y;
                var iter = 0;
                var max_iter = img.data.length / 4;
                var trace = []
                var opaque = false;
                do {
                    opaque = false;
                    var it = 0;
                    dir = offsetDir(dir, 2);
                    while ((!opaque) && (it < 8)) {
                        var off = getOffset(dir);
                        var color = getImgPixelAt(img, x + off.x, y + off.y);
                        opaque = color == null ? false: color.r > 0;
                        if (!opaque) {
                            it++;
                            dir = prevDir(dir);
                        } else {
                            result.addCode(dir);
                            trace.push(new Point(x, y));
                            x += off.x;
                            y += off.y;
                        }
                    }
                    iter++;
                } while (((x != sx) || (y != sy)) && (opaque) && (iter < max_iter));
                for (var i = 0; i < trace.length; i++) {
                    setImgPixelAt(img, trace[i].x, trace[i].y, new Color(255, 0, 0, 255));
                }
                setImgPixelAt(img, sx, sy, new Color(0, 255, 0, 255));
                ctx.mozImageSmoothingEnabled = false;
                ctx.webkitImageSmoothingEnabled = false;
                ctx.msImageSmoothingEnabled = false;
                ctx.imageSmoothingEnabled = false;
                return {
                    "start": new Point(sx, sy),
                    "code": result,
                    "trace": trace
                };
            }
            return null;
        } catch(err) {
            alert("boundary: " + err);
        }
    }

    var fill = function(img, boundary, color) {
        // Determine fill region.
        var min = new Point(img.width - 1, img.height - 1);
        var max = new Point(0, 0);
        for (var i = 0; i < boundary.trace.length; i++) {
            if (boundary.trace[i].x > max.x) {
                max.x = boundary.trace[i].x;
            }
            if (boundary.trace[i].x < min.x) {
                min.x = boundary.trace[i].x;
            }
            if (boundary.trace[i].y > max.y) {
                max.y = boundary.trace[i].y;
            }
            if (boundary.trace[i].y < min.y) {
                min.y = boundary.trace[i].y;
            }
        }
        // Boundary map.
        var width = (max.x - min.x) + 1;
        var height = (max.y - min.y) + 1;
        var boundary_map = new Array(width * height);
        // Fill with false value.
        for (var i = 0; i < boundary_map.length; i++) {
            boundary_map[i] = false;
        }
        for (var i = 0; i < boundary.trace.length; i++) {
            boundary_map[(boundary.trace[i].x - min.x) + ((boundary.trace[i].y - min.y) * width)] = true;
        }
        var boundaryAt = function(tx, ty) {
            return boundary_map[tx + (ty * width)];
        }
        // Start filling.
        // Flood fill.
        var x = boundary.start.x - min.x + 1;
        var y = boundary.start.y - min.y + 1;
        var next = []
        var indexOf = function(x, y) {
            var found = false;
            var i = 0;
            while ((!found) && (i < next.length)) {
                found = ((x === next[i].x) && (y === next[i].y));
                if (!found) {
                    i++;
                }
            }
            if (found) {
                return i;
            }
            return -1;
        }
        var iter = 0;

        var startFill = function(x, y) {
            next.push(new Point(x, y));
            while (next.length > 0) {
                var curr = next.pop();
                x = curr.x;
                y = curr.y;
                if (!boundaryAt(x, y)) {
                    boundary_map[x + (y * width)] = true;
                    setImgPixelAt(img, x + min.x, y + min.y, color);
                    iter++;
                    if (!boundaryAt(x + 1, y)) {
                        if (indexOf(x + 1, y) === -1) {
                            next.push(new Point(x + 1, y));
                        }
                    }
                    if (!boundaryAt(x, y + 1)) {
                        if (indexOf(x, y + 1) === -1) {
                            next.push(new Point(x, y + 1));
                        }
                    }
                    if (!boundaryAt(x - 1, y)) {
                        if (indexOf(x - 1, y) === -1) {
                            next.push(new Point(x - 1, y));
                        }
                    }
                    if (!boundaryAt(x, y - 1)) {
                        if (indexOf(x, y - 1) === -1) {
                            next.push(new Point(x, y - 1));
                        }
                    }
                }
            }
        }
        
        startFill(x, y);
        for (var i = 0; i < boundary.trace.length; i++) {
            setImgPixelAt(img, boundary.trace[i].x, boundary.trace[i].y, color);
        }
        return img;
    }

    var matchAll = function(code, maxerror=-1) {
        /* return all name of preset that matches the code with maximum number of error <= maxerror.
         use maxerror === -1 to return all.
         return:
         [
             {
                 "name": ...,
                 "error": ...
             }
         ]
         */
        var result = []
        for (var name in preset) {
            var error = code.match(preset[name]);
            if ((maxerror === -1) || (error < maxerror)) {
                result.push({
                    "name": name,
                    "error": error
                });
            }
        }
        return result;
    }

    // Eight-directional neighbours
    var neighbours =  [[0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1]];

    // Neighbours Group from Zhang-Suen Rules
    var neighboursGroup = [[[0, 2, 4], [2, 4, 6]], [[0, 2, 6], [0, 4, 6]]];
    
    function skeletonizeImage(img) {
        var firstStep = 0;
        var toBlack = new Array();
        var hasChanged;
        do {    // repeatly checking for reomving side to get the skeleton
            hasChanged = false;
            firstStep = (firstStep + 1) % neighboursGroup.length;
            for (var i = 0; i < img.data.length; i += 4) {
                if (img.data[i] != 255)
                    continue;
                var num = nNeighbours(img, i);
                if (num < 2 || num > 6)
                    continue;
                if (nTransition(img, i) != 1)
                    continue;
                if (!atLeastOneBlack(img, i, firstStep))
                    continue;
                toBlack.push(i);
                hasChanged = true;
            }
            for (var i = 0; i < toBlack.length; i++){
                img.data[toBlack[i]] = 0;
                img.data[toBlack[i] + 1] = 0;
                img.data[toBlack[i] + 2] = 0;
            }
            toBlack = new Array();
            
        } while((firstStep || hasChanged));

        return img;
    }

    function nNeighbours(img, idx) {
        /*
        Find white surroundings on the all eight-directions
        */
        var count = 0;
        var temp;
        
        var tempRow = Math.floor(idx / img.width / 4);
        var tempCol = Math.floor((idx % (img.width * 4) / 4));
        for (var i = 0; i < neighbours.length - 1; i++) {
            temp = ((tempRow + neighbours[i][1]) * img.width * 4)+ ((tempCol + neighbours[i][0]) * 4);
            if (img.data[temp] == 255){
                count++;
            }
        }
        return count;
    }

    function nTransition(img, idx) {
        /*
        Find total transition from 0 (black) to 255 (white) from the surroundings
        */
        var count = 0;
        var temp1, temp2;
        
        var tempRow = Math.floor(idx / img.width / 4);
        var tempCol = Math.floor((idx % (img.width * 4) / 4));
        for (var i = 0; i < neighbours.length - 1; i++) {
            temp1 = ((tempRow + neighbours[i][1]) * img.width * 4) + ((tempCol + neighbours[i][0]) * 4);
            temp2 = ((tempRow + neighbours[i + 1][1]) * img.width * 4) + ((tempCol + neighbours[i + 1][0]) * 4);
            if (img.data[temp1] === 0)
                if (img.data[temp2] === 255)
                    count++;
        }
        temp1 = ((tempRow + neighbours[neighbours.length - 1][1]) * img.width * 4) + ((tempCol + neighbours[neighbours.length - 1][0]) * 4);
        temp2 = ((tempRow + neighbours[0][1]) * img.width * 4) + ((tempCol + neighbours[0][0]) * 4);
        if (img.data[temp1] === 0)
            if (img.data[temp2] === 255)
                count++;
        return count;
    }

    function atLeastOneBlack(img, idx, step) {
        /*
        Find at least one black from the surrounding according to the neighbours groups
        */
        var count = 0;
        var temp;
        var group = neighboursGroup[step];
        var tempRow = Math.floor(idx / img.width / 4);
        var tempCol = Math.floor((idx % (img.width * 4) / 4));

        for (var i = 0; i < 2; i++) {
            for (var j = 0; j < group[i].length; j++) {
                var surround = neighbours[group[i][j]];
                temp = ((tempRow + surround[1]) * img.width * 4) + ((tempCol + surround[0]) * 4);
                if (img.data[temp] === 0) {
                    count++;
                    break;
                }
            }
        }
        return count > 1;
    }

    var boldNeighbours = [[[1,1],[1,0]],[[1,1],[0,1]],[[-1,1],[-1,0]],[[-1,1],[0,1]],[[-1,-1],[-1,0]],[[-1,-1],[0,-1]],[[1,-1],[1,0]],[[1,-1],[0,-1]]]
    // var endPoints = []
    // var crucialPoints = []
    function delBoldNeighbours(img, idx, crucialPoints){
        var triplePoint = true
        var tempRow = Math.floor(idx / img.width / 4);
        var tempCol = Math.floor((idx % (img.width * 4) / 4));
        for (i = 0; i < boldNeighbours.length; i++){
            temp1 = ((tempRow + boldNeighbours[i][0][1]) * img.width * 4)+ ((tempCol + boldNeighbours[i][0][0]) * 4)
            temp2 = ((tempRow + boldNeighbours[i][1][1]) * img.width * 4)+ ((tempCol + boldNeighbours[i][1][0]) * 4)
            if (img.data[temp1] == 255 && img.data[temp2] == 255 && !(crucialPoints.includes(temp2))){
                img.data[temp2] = 0
                img.data[temp2 + 1] = 0
                img.data[temp2 + 2] = 0
            }
        }
    }
    function findCrucialPoints (img){
        var crucialPoints = []
        for (var i = 0; i < img.data.length; i += 4){
            if (nTransition(img, i) > 2 && img.data[i] == 255){
                crucialPoints.push(i)
            }
        }
        return crucialPoints
    }
    function findEndPoints(img) {
        var endPoints = []
        for (var i = 0; i < img.data.length; i += 4) {
            if (img.data[i] == 255){
                var num = nNeighbours(img, i)
                if (num == 1) {         // Found end points
                    endPoints.push(i)
                }
            }
        }
        return endPoints;
    }
    
    function findTriplePoints (img){
        var triplePoint = []
        for (var i = 0; i < img.data.length; i += 4){
            if (nTransition(img, i) == 3 && img.data[i] == 255 && nNeighbours(img, i) == 3){
                triplePoints.push(i)
            }
        }
        return triplePoints
    }
    function postprocessImage(img){
        var endPoints = [];
        var crucialPoints = findCrucialPoints(img);
        // console.log(triplePoints)
        for (var i = 0; i < img.data.length; i += 4) {
            if (img.data[i] == 255){
                var num = nNeighbours(img, i);
                if (num == 1) {         // Found end points
                    endPoints.push(i);
                }
                else if (num == 2){     // Ordinary connected pixel
                    // do nothing
                }
                else{     // Found multiple points
                    delBoldNeighbours(img, i, crucialPoints);
                }
            }
        }
        triplePoints = [];
        triplePoints = findTriplePoints(img);
        imgNew = removeFakeLines(img, endPoints, triplePoints, crucialPoints);
        return imgNew;
        //return img
    }
    function diagonalLength(A, B, img){
        xA = Math.floor((A % (img.width * 4) / 4));
        yA = Math.floor(A / img.width / 4);
        xB = Math.floor((B % (img.width * 4) / 4));
        yB = Math.floor(B / img.width / 4);

        return Math.sqrt(((xA - xB) * (xA - xB)) + ((yA - yB) * (yA - yB)))
    }

    function removeFakeLines(img, endPoints, triplePoints, crucialPoints){
        var suspectValue = []
        for (var i = 0; i < triplePoints.length; i++){
            var len = diagonalLength(triplePoints[i], endPoints[0], img)
            suspectValueN = endPoints[0];
            for (var j = 0; j < endPoints.length; j++){
                if (diagonalLength(triplePoints[i], endPoints[j], img) < len){
                    len = diagonalLength(triplePoints[i], endPoints[j], img)
                    suspectValueN = endPoints[j]
                }
            }
            suspectValue.push(suspectValueN)
        }

        for (var i = 0; i < triplePoints.length; i++){
            var tempPointer = []
            pointer = triplePoints[i]
            if (endPoints.length != 0){
                while (pointer != suspectValue[i] && !crucialPoints.includes(suspectValue[i])){
                    tempPoint = []
                    change = false
                    var tempRow = Math.floor(pointer / img.width / 4);
                    var tempCol = Math.floor((pointer % (img.width * 4) / 4));
                    for (var j = 0; j < neighbours.length; j++) {
                        temp = ((tempRow + neighbours[j][1]) * img.width * 4)+ ((tempCol + neighbours[j][0]) * 4);
                        if (img.data[temp] == 255){
                            tempPoint.push(temp)
                        }   
                    }
                    len = diagonalLength(pointer, suspectValue[i], img)
                    for (var j = 0; j < tempPoint.length; j++){
                        if (diagonalLength(tempPoint[j], suspectValue[i], img) < len){
                            len = diagonalLength(tempPoint[j], suspectValue[i], img);
                            pointer = tempPoint[j];
                            change = true
                            tempPointer.push(pointer)
                        }
                    }
                    if (change){
                        var index = crucialPoints.indexOf(pointer);
                        if (index > -1) {
                            crucialPoints.splice(index, 1);
                        }
                        index = endPoints.indexOf(pointer);
                        if (index > -1) {
                            endPoints.splice(index, 1);
                        }
                        img.data[pointer] = 0;
                        img.data[pointer + 1] = 0;
                        img.data[pointer + 2] = 0;
                    }
                    else{
                        for (var j = 0; j < tempPointer.length; j++){
                            img.data[tempPointer[j]] = 255;
                            img.data[tempPointer[j] + 1] = 255;
                            img.data[tempPointer[j] + 2] = 255;
                        }
                        break;
                    }
                }
            }
        }
        return img
    }

    $(document).ready(function() {
        loadPreset();
    });

</script>